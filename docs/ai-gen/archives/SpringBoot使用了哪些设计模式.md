<think>
嗯，用户问的是“Spring Boot使用了哪些设计模式”。我得先回忆一下Spring Boot的架构和特性，然后把这些特性映射到各种设计模式上。

首先，依赖注入和控制反转，这肯定是其中之一。Spring的核心就是DI，所以这个必须提到。

然后是模板方法模式，比如在启动类中使用@SpringBootApplication注解，这其实是一个模板方法的应用，让用户按需扩展而不改变固有逻辑。

工厂方法模式可能体现在自动配置类的生成，或者Bean的创建过程中。我需要具体例子来说明这个点。

适配器模式，比如将Tomcat引擎包装成Servlet容器，这个应该算适配器吧。还有像数据源的适配器，比如连接池的实现。

代理模式可能在AOP里用到了，动态代理生成子类来实现切面逻辑。这部分需要详细解释一下。

观察者模式在事件处理中使用，比如ApplicationEventPublisher发布事件，其他组件监听这些事件，这就是典型的观察者模式。

单例模式肯定是有的，因为很多Bean默认都是单例的，但Spring Boot进一步简化了这点，用户不需要特别配置。

外观模式可能体现在为Tomcat、Jetty等Servlet容器提供统一的引擎接口，让用户不用关心具体实现细节。

策略模式可能在自动配置中，比如选择不同的连接池策略，这个可以通过配置文件来决定。

组合模式可能用于构建应用上下文，整合各个部分，形成一个完整的应用环境。

装饰者模式比如对Filter的链式处理，每个Filter都添加一些额外功能，这就是装饰者的典型应用。

还有可能涉及到其他模式，比如责任链模式在处理请求的时候，用来分解处理步骤。

总结一下，我应该把这些设计模式逐一列出来，并给出具体的例子和说明，让用户能够明白Spring Boot是如何利用这些模式来实现其功能的。
</think>

Spring Boot作为一个现代化的Java应用开发框架，内部使用了多种设计模式来提升代码的可维护性、扩展性和复杂度控制。以下是一些在Spring Boot中常见使用的设计模式：

### 1. **依赖注入（Dependency Injection）**
   - **描述**：依赖注入是Spring框架的核心之一，也被称为控制反转（IoC，Inversion of Control）。它允许组件从外部获取依赖项，而不是自行创建依赖项。
   - **应用场景**：在Spring Boot中，大量使用`@Autowired`、`@Value`等注解来实现依赖的注入。框架会自动管理Bean的生命周期和依赖关系。

### 2. **模板方法模式（Template Method Pattern）**
   - **描述**：定义一个操作的算法骨架，将一些步骤延迟到子类中，使得子类可以不改变算法的结构就能重定义该算法的某些特定步骤。
   - **应用场景**：Spring Boot的启动类通常使用`@SpringBootApplication`注解，并通过实现`CommandLineRunner`或`ApplicationRunner`接口来扩展启动时的逻辑。这种方式遵循模板方法模式，用户可以在固定的流程中添加自定义逻辑。

### 3. **工厂方法模式（Factory Method Pattern）**
   - **描述**：提供一个创建对象的接口，让子类决定实例化哪个类。
   - **应用场景**：Spring Boot使用工厂方法模式来生成自动配置类（AutoConfiguration），通过`@EnableAutoConfiguration`注解，框架会根据类路径中的库生成相应的配置。

### 4. **适配器模式（Adapter Pattern）**
   - **描述**：将一个对象转换为另一个接口，使得两个不兼容的对象能够协同工作。
   - **应用场景**：在Spring Boot中，例如将Tomcat引擎包装成一个Servlet容器（`EmbeddedServletContainerFactory`），或者在数据源配置时使用适配器来支持不同的连接池实现。

### 5. **代理模式（Proxy Pattern）**
   - **描述**：为对象提供一个替代品，以控制对该对象的访问。
   - **应用场景**：Spring Boot中的AOP（面向切面编程）模块使用动态代理来生成被代理对象的子类或接口实现，用于织入切面逻辑。

### 6. **观察者模式（Observer Pattern）**
   - **描述**：定义一个订阅和通知机制，使得对象在状态变化时能够通知所有依赖它的对象。
   - **应用场景**：Spring Boot支持事件处理机制，例如通过`ApplicationEventPublisher`发布事件，其他组件可以监听这些事件并做出相应反应。

### 7. **单例模式（Singleton Pattern）**
   - **描述**：确保一个类只有一个实例，并提供一个全局访问点。
   - **应用场景**：在Spring Boot中，默认情况下Bean都是单例的。通过`@Scope`注解可以控制Bean的作用域，但默认是单例模式。

### 8. **外观模式（Facade Pattern）**
   - **描述**：为一组复杂的子系统提供一个简单、统一的接口，使其更容易使用。
   - **应用场景**：Spring Boot通过`@EnableAutoConfiguration`和`@SpringBootApplication`注解，为配置提供了一个简化的外观，隐藏了很多底层细节。

### 9. **策略模式（Strategy Pattern）**
   - **描述**：定义一系列算法，把它们封装起来，并且可以互换。
   - **应用场景**：在Spring Boot中，可以通过配置文件选择不同的策略。例如，在数据库连接池的实现中，可以根据配置选择使用HikariCP、Druid或其他连接池。

### 10. **组合模式（Composite Pattern）**
   - **描述**：将对象组成树结构，以表示部分-整体层次结构，使得客户可以统一对待单个对象和组合对象。
   - **应用场景**：在Spring Boot中，`ApplicationContext`作为一个组合对象，它可能包含多个子容器（Child Context），而这些子容器中的Bean可以被整个上下文访问。

### 11. **装饰者模式（Decorator Pattern）**
   - **描述**：动态地给对象添加额外的责任。
   - **应用场景**：Spring Boot中的一些过滤器（Filter）实现使用了装饰者模式，例如对请求和响应进行包装处理。

### 12. **责任链模式（Chain of Responsibility Pattern）**
   - **描述**：为处理不同类型的请求提供了一系列可能的处理器，使得这些处理器可以依次处理请求。
   - **应用场景**：在Spring Boot的Web应用中，多个过滤器按照一定顺序处理请求，每个过滤器都可以对请求进行修改或终止处理，这种链式处理机制符合责任链模式。

### 总结
通过使用这些设计模式，Spring Boot实现了高效、灵活且易于扩展的应用开发。开发者无需深入理解这些模式的具体实现细节，就能快速构建企业级应用，而Spring Boot内部则依靠这些模式来管理复杂性并提供简化的API。