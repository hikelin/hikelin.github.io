<think>
嗯，我现在在学习Java，老师布置了一道题目，让我看看JDK用了哪些设计模式。我对这个还不是很了解，但先试着回忆一下课本上的内容。

首先，我知道设计模式是一些常用的解决问题的方法或者说是经验的总结。JDK作为一个成熟的开发工具包，肯定用了很多设计模式来构建它的各种功能和类库。那我得想一想，JDK里有哪些地方明显用到了这些模式。

第一个想到的是单例模式。我记得单例模式是指只能创建一个实例的类，比如说Runtime类，它只有一个实例。还有ClassLoader，用来加载类的时候也是单例吗？或者说每个类加载器可能是一个单例？可能吧，这样可以保证线程安全和资源管理。

然后，工厂方法模式。我记得这个模式是关于创建对象的，对吧？JDK里有很多地方用到了，比如说集合框架中的Iterator。比如ArrayList、LinkedList，他们各自实现了 iterator() 方法，返回不同的迭代器实例。这应该就是工厂方法的一个应用，因为它们都继承了一个接口或者抽象类，并且重写了next()和hasNext()这样的方法。

观察者模式，这个我记得在Swing库中用到了，比如说JButton，当点击按钮的时候，会触发事件，然后所有注册的监听器都会被通知到。所以ActionListener就是一个观察者的例子，它们在按钮被点击时会收到通知并执行相应的动作。

装饰者模式，我记得IO类库用了这个模式。比如说BufferedInputStream，它是在InputStream的基础上增加了一些功能，比如缓冲。这样可以动态地添加功能，而不需要改变原有的类结构。这应该就是装饰者的做法，通过包装对象来扩展功能。

代理模式，这个可能在各种地方都用到了，比如说动态代理。比如，RMI（远程方法调用）中的远程代理，它们会拦截方法调用，并进行一些处理，如网络通信。这应该就是典型的代理模式应用，因为它通过一个对象来控制对另一个对象的访问。

原型模式，这个可能用在类加载机制中，比如说PrototypeInputStream。我记得这个类是用于克隆输入流的，每次获取的时候都是克隆一个原型对象。这样可以避免每次都重新创建，从而提高效率。

组合模式，在 Swing 的组件树中，容器可以包含其他组件和子容器，比如JPanel里面可以放很多按钮、标签等等。这形成了一个树状结构，这就是组合模式的应用，让客户端统一处理叶节点和容器，而不需要区分对待。

适配器模式，在collections框架中有一个类，比如Arrays.asList()，它会把数组转换成一个List对象。或者像Enumeration到Iterator的适配器，这样旧的代码可以与新的接口兼容。这就是通过适配器来连接两个不兼容的接口。

桥梁模式，我记得在JDBC中的Statement和PreparedStatement之间用了这个模式。它们有共同的接口，但各自实现不同的功能，而驱动程序则作为桥梁，允许不同类型的语句使用不同的驱动处理。这可能就是桥梁模式的应用，将抽象与实现分离。

策略模式，在HTTP客户端处理中，可能会用到不同的策略，比如不同的连接策略或者处理方式。比如HttpURLConnection可以设置不同的请求方法（GET、POST等），这可能对应于不同的策略实现。

模板方法模式，在集合框架中的AbstractList类，它提供了一个抽象的列表实现，其中像add()、remove()这样的方法由子类具体实现，而模板方法则定义了算法的步骤。比如，某些操作会在子类中进行具体处理，但整体流程是在抽象类中控制的。

迭代器模式，这个很明显，在集合框架里，每一个集合都有自己的迭代器，用来遍历元素。比如ArrayList的iterator()方法返回一个Iterator对象，用于逐一访问每个元素，并且可以通过next()和hasNext()来控制遍历过程。

总结一下，我应该从单例、工厂方法、观察者、装饰者、代理、原型、组合、适配器、桥梁、策略、模板方法和迭代器这些模式入手，每个模式举一个JDK中的具体例子，这样就能系统地回答这个问题了。

不过，我可能记错了一些细节，比如类名或者应用的具体场景。比如，原型模式中使用的是PrototypeInputStream吗？这点我不太确定，可能需要查证一下。另外，桥梁模式在JDBC中的具体实现是否准确，这个也得再确认。

还有，策略模式和模板方法模式有时候容易混淆，我是不是把例子搞反了呢？比如，HttpURLConnection设置请求方法是不是更像是策略模式，而AbstractList的add方法则属于模板方法。可能没问题，但最好再想想两者的区别。

总之，大致思路应该是这样的，现在我可以开始组织语言，把每个模式和对应的JDK例子列出来，这样就能回答老师的问题了。
</think>

JDK 在设计时运用了多种设计模式来构建其功能模块。以下是一些主要应用的设计模式及其示例：

1. **单例模式 (Singleton Pattern)**
   - **示例**：`Runtime` 类，确保只存在一个实例以管理系统资源。
   
2. **工厂方法模式 (Factory Method Pattern)**
   - **示例**：集合框架中的 `Iterator`，不同集合类（如 `ArrayList`, `LinkedList`）实现各自的迭代器。

3. **观察者模式 (Observer Pattern)**
   - **示例**：Swing 库中的事件监听器，如 `ActionListener` 在按钮点击时触发。

4. **装饰者模式 (Decorator Pattern)**
   - **示例**：IO 类库中的 `BufferedInputStream`，在输入流上添加缓冲功能。

5. **代理模式 (Proxy Pattern)**
   - **示例**：动态代理和 RMI 远程代理，拦截方法调用进行处理，如网络通信。

6. **原型模式 (Prototype Pattern)**
   - **示例**：`PrototypeInputStream` 克隆输入流以提高效率。

7. **组合模式 (Composite Pattern)**
   - **示例**：Swing 组件树，容器（如 `JPanel`）管理子组件和嵌套容器。

8. **适配器模式 (Adapter Pattern)**
   - **示例**：将数组转换为列表的 `Arrays.asList()`，以及旧接口到新接口的适配。

9. **桥梁模式 (Bridge Pattern)**
   - **示例**：JDBC 中的 `Statement` 和 `PreparedStatement` 使用不同驱动处理。

10. **策略模式 (Strategy Pattern)**
    - **示例**：HTTP 客户端中的不同请求方法（如 GET、POST）。

11. **模板方法模式 (Template Method Pattern)**
    - **示例**：集合框架的 `AbstractList` 类，定义算法骨架由子类实现细节。

12. **迭代器模式 (Iterator Pattern)**
    - **示例**：集合框架中的迭代器对象，遍历集合元素。

这些设计模式在JDK中广泛应用，增强了代码的可维护性、扩展性和复用性。每个模式解决特定问题，如单例管理资源、工厂方法创建对象、观察者处理事件等，从而构建高效且灵活的系统架构。